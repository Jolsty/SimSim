%
% Tesi D.S.I. - modello preso da
% Stanford University PhD thesis style -- modifications to the report style
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                         %
%			TESI DOTTORATO                                                %
%			______________                                                %
%                                                                         %
%			AUTORE: Andrei Ciulpan                                        %
%                                                                         %
%			Ultima revisione: 31.05.2019                                  %
%                                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
\documentclass[12pt]{report}
%    \renewcommand{\baselinestretch}{1.6}      % interline spacing
%
% \includeonly{}
%
%			PREAMBOLO
%
\usepackage[a4paper]{geometry}
\usepackage{amssymb,amsmath,amsthm}
\usepackage{graphicx}
\usepackage[hyphens,spaces,obeyspaces]{url}
\usepackage{hyperref}
\usepackage{epsfig}
\usepackage[italian]{babel}
\usepackage{tesi}
\usepackage{afterpage}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{enumerate}

\renewcommand{\UrlFont}{\footnotesize}

\newcolumntype{L}{>{\raggedright\arraybackslash}X}

\addto{\captionsitalian}{%
	\renewcommand{\bibname}{Sitografia}
}

\lstset{
	extendedchars=true,
	basicstyle=\footnotesize\ttfamily,
	showstringspaces=false,
	showspaces=false,
	numbers=left,
	numberstyle=\footnotesize,
	numbersep=9pt,
	tabsize=2,
	breaklines=true,
	showtabs=false,
	captionpos=b
}

\newcommand\blankpage{%
	\null
	\thispagestyle{empty}%
	\addtocounter{page}{-1}%
	\newpage}

% per le accentate
\usepackage[utf8]{inputenc}
%
\newtheorem{myteor}{Teorema}[section]
%
\newenvironment{teor}{\begin{myteor}\sl}{\end{myteor}}
%
%
%			TITOLO
%
\begin{document}

\title{Sistema Accessi IoT}
\author{Andrei CIULPAN}
\dept{Corso di Laurea in Informatica} 
\anno{2018/2019}
\matricola{872394}
\relatore{Andrea TRENTINI}
\correlatore{Marco LANZA}
\afterpage{\blankpage}
% 
%			DEDICA
%
\beforepreface

{\hfill \footnotesize {\sl Ringrazio i miei genitori e la nonna per il sostegno e per la pazienza che hanno avuto.}}
\vskip 0.8cm
{\hfill \footnotesize {\sl Ringrazio i miei amici e compagni di università per aver reso l'esperienza più bella e soprattutto più facile.}}
\vskip 0.8cm
{\hfill \footnotesize {\sl Ringrazio i miei tutor e colleghi per avermi dato la possibilità di crescere e concludere la mia esperienza universitaria.}}
\vskip 0.8cm
{\hfill \footnotesize {\sl Un ringraziamento speciale a Elena per essere riuscita a farmi sorridere e a tirarmi su il morale in ogni giorno con la sua presenza nella mia vita.  Un altro ringraziamento a lei per la revisione della tesi.}}
       

\afterpreface

%			CAPITOLO 1: Intro
\chapter{Introduzione}\label{cap:introduzione}
%

Il controllo accessi è un sistema di protezione che permette l'accesso solo a determinate persone per via di qualche procedura di autenticazione: nel mondo fisico si può parlare di una semplice serratura (storicamente il sistema più utilizzato in assoluto) che può essere aperta solo dalle persone in possesso della chiave, mentre nel mondo dell'informatica si può notare l'enorme utilizzo delle procedure di autenticazione (login) che aiutano il sistema, tramite l'inserimento di un nome utente e password, a determinare automaticamente se una persona è autorizzata ad accedere alle risorse del sistema stesso.

Il controllo accessi\cite{controllo_accessi} è un tema molto sviluppato nel campo della sicurezza sia fisica che informatica: è stato segnalato che nel 2017, per il secondo anno consecutivo, il mercato del controllo accessi ha avuto la crescita più rapida nell'industria della sicurezza fisica\cite{crescita_controllo_accessi}. E' anche un sistema onnipresente, utilizzato in ospedali, fabbriche, supermercati, aziende, sistemi di trasporto pubblico (e.g l'ATM di Milano), case e tanti altri campi.  

La tesi si propone di trattare un sistema ibrido in cui il mondo fisico e il mondo informatico lavorano insieme: attraverso sensori ed attuatori è possibile avere la comunicazione tra i due mondi. 

Si tratta di un sistema IoT (Internet of Things), ovvero un sistema in cui la connessione Internet viene estesa anche al mondo degli oggetti fisici (smart objects\cite{smart_objects}) di uso comune. Gli oggetti si rendono riconoscibili e "acquisiscono intelligenza" grazie al fatto di possedere una o più delle seguenti funzionalità: identificazione, localizzazione, diagnosi di stato, interazione con l'ambiente circostante, elaborazione dati e ovviamente connessione.
Gli oggetti intelligenti di un sistema IoT sono normalmente dotati di un processore embedded, sensori e attuatori e sono in grado di agire sui dati raccolti dall'ambiente e, ancora più importante, mandare questi dati in rete dove possono poi essere analizzati\cite{IoT}. Un semplice esempio di un sistema IoT si può trovare nella Figura \ref{fig:iot_diagram}.

Le seguente sezione di questo capitolo introdurrà il progetto stesso (denominato SimSim) che poi verrà dettagliato nei prossimi capitoli.

\begin{figure}
	\includegraphics[width=\linewidth]{./img/iot_diagram.png}
	\caption{Esempio di sistema IoT}
	\label{fig:iot_diagram}
\end{figure}


%
\section{Requisiti del progetto}\label{sec:req}
%

L'attività principale del tirocinio è la realizzazione di un sistema di controllo accessi, da applicare presso varchi. Vengono elencati i requisiti del sistema:

\begin{enumerate}
	\item Deve essere in grado di funzionare con diverse modalità di riconoscimento:
	\begin{enumerate}
		\item Tessera RFID
		\item Tastierino numerico (password)
		\item Telecomando 
	\end{enumerate}
	\item Deve dare la possibilità di visualizzare su un display LCD ciò che sta succedendo (accesso consentito/negato ecc...). Inoltre deve essere implementata una funzione che permetta di visualizzare i codici delle tessere RFID sul display LCD (operazione protetta da una password).
	\item A seguito di ogni accesso avvenuto con successo deve aprire una porta (usando un servomotore) e salvare il log in un database remoto (in LAN) tramite WiFi.
	\item Deve avere un database per:
	\begin{enumerate}
		\item Tessere RFID
		\item Log degli accessi
		\item Soci
	\end{enumerate}
	\item Deve avere un'interfaccia grafica (in questo caso sito web) tramite la quale l'utente amministratore possa gestire il database con le seguenti funzioni: 
	\begin{enumerate}
		\item Aggiungere/modificare/cancellare soci 
		\item Aggiungere/modificare/cancellare tessere 
		\item Visualizzare log
	\end{enumerate}
\end{enumerate}
I dispositivi scelti per soddisfare i requisiti sono stati un Arduino UNO (per la parte hardware) e un Raspberry Pi 3B+ su cui ospitare il server. 

Nella figura \ref{fig:simsim} si può vedere una foto con il prototipo finito.
Nelle figure \ref{fig:usecase} e \ref{fig:flowchart} si possono trovare rispettivamente un diagramma dei casi d'uso e un diagramma di flusso del sistema.

\begin{figure}
	\includegraphics[width=1\linewidth]{./img/simsim.jpeg}
	\caption{SimSim}
	\label{fig:simsim}
\end{figure}

\begin{figure}
	\center{\includegraphics[width=0.6\linewidth]{./img/usecase.png}}
	\caption{Casi d'uso del sistema}
	\label{fig:usecase}
\end{figure}

\begin{figure}
	\center{\includegraphics[width=0.9\linewidth]{./img/flowchart.png}}
	\caption{Diagramma di flusso del sistema}
	\label{fig:flowchart}
\end{figure}


%			CAPITOLO 2
\chapter{Sviluppo del sistema embedded}
\label{cap2}
%

In questo capitolo vengono dettagliati i dispositivi hardware utilizzati all'interno del sistema embedded. Uno schema completo del circuito elettrico si trova nella Figura \ref{fig:schematics}.

\begin{figure}
	\center{\includegraphics[width=\textwidth,height=1.1\textheight,keepaspectratio]{./img/schematics.png}}
	\caption{Schema del circuito}
	\label{fig:schematics}
\end{figure}


%
\section{Raspberry Pi}
%


\begin{figure}
	\center{\includegraphics[width=0.4\linewidth]{./img/raspi.jpg}}
	\caption{Scheda Raspberry Pi}
	\label{fig:raspi}
\end{figure}

Raspberry Pi (Figura \ref{fig:raspi}) è una serie di piccoli computer (system-on-chip) dalle dimensioni simili a quelle di una carta di credito. La scheda è stata sviluppata nel Regno Unito (Fondazione Raspberry Pi). Le prime versioni avevano poca potenza computazionale e sono state progettate con l'intenzione di offrire a insegnanti e studenti uno strumento semplice e poco costoso con cui poter insegnare e imparare a programmare. La scheda ha avuto un enorme successo anche in altri campi (e.g$.$ robotica) e con ogni nuova versione è stata migliorata. Le ultime versioni sono assai potenti e possono essere utilizzate per tante altre cose. Le schede sono basate su sistemi operativi di tipo GNU/Linux, in particolare Raspbian che può essere scaricato dal sito della fondazione (\url{https://www.raspberrypi.org/downloads/}). 

La scheda utilizzata nel progetto (Raspberry Pi 3B+, \url{https://www.raspberrypi.org/products/raspberry-pi-3-model-b-plus/}) possiede un'architettura su 64 bit, essenziale per poter utilizzare in maniera efficiente MongoDB (che è limitato a una memoria di 2 GB su un sistema a 32bit). Durante lo sviluppo del progetto ho scoperto che Raspbian in realtà non è stato ancora aggiornato per essere un sistema operativo a 64 bit, perciò non poteva sfruttare al meglio la scheda. Come soluzione a questo problema, è stato installato un sistema operativo chiamato openSUSE Tumbleweed (\url{https://software.opensuse.org/distributions/tumbleweed}) che funziona su architetture a 64 bit. 
Il Raspberry Pi 3B+ possiede inoltre una scheda WiFi, il che la rende un buon candidato per lo scopo principale del progetto, ovvero quello di ospitare il server.


%
\section{Arduino UNO}
%

Arduino\cite{arduino_storia} è nata ad Ivrea nel 2005 come piattaforma di prototipazione elettronica di basso costo e open-source (dettaglio molto importante che ha portato al successo che ha avuto) che si basa su hardware e software flessibili e facili da usare. Il nome della scheda deriva di quello del bar di Ivrea frequentato dai fondatori del progetto ed la scheda è stata creata per artisti, designer e hobbisti. Essendo open-source, ha avuto un grande successo nel mondo degli hobbisti, anche a livello mondiale (tale da diventare una delle invenzioni più considerevoli nella storia dell'elettronica), grazie alla facilità di programmazione, basso costo e soprattutto disponibilità in rete delle informazioni necessarie per poter permettere a persone con grandi idee e poche capacità informatiche ed elettroniche di realizzare i propri progetti. 

Al giorno d'oggi Arduino potrebbe anche non essere la scelta immediata, anzi, ormai ci sono schede più potenti, più veloci e con migliori rapporti prestazioni/prezzo, ma non scordiamoci che è tutto grazie agli sviluppatori della scheda. Perchè scegliere, quindi, un Arduino? Essendo la scheda che ha fatto partire tutto, è anche la scheda più studiata e ciò significa che gira intorno a più informazioni, più librerie già pronte, più dispositivi compatibili e ha anche un sito di appassionati che si aiutano a vicenda dove si possono trovare tutorial, libri e tant'altro.

La scheda utilizzata nel progetto, Arduino UNO (Figura \ref{fig:uno}), è assolutamente la scheda più conosciuta al mondo e si può ormai trovare a dei prezzi molto bassi (ci sono tanti clone diversi in rete grazie al fatto di essere OpenHardware). Tra le varie caratteristiche vengono elencate le più interessanti:

\begin{itemize}
	\item Microcontrollore: ATmega328 (\url{https://www.sparkfun.com/datasheets/Components/SMD/ATMega328.pdf})
	\item Digital I/O Pins: 14 tra cui 6 offrono la funzione PWM (si veda la sezione \ref{sec:servomotore} "Servomotore") e 4 implementano il protocollo SPI (si veda la sezione \ref{sec:spi} "SPI")
	\item Analog I/O Pins: 6 tra cui 2 implementano il protocollo I$^2$C (si veda la sezione \ref{sec:i2c} "I$^2$C")
	\item Flash Memory: 32 KB
	\item EEPROM: 1 KB
	\item Clock Speed: 16 MHz
	\item DC Current per i pin I/O: max 40 mA
	\item DC Current per il pin 3V3: max 50 mA
	\item Operating Voltage: 5V
	\item Input Voltage (recommended): 7-12V
\end{itemize}

L'Arduino UNO è quindi un dispositivo ideale per il progetto; l'unica cosa che manca è la possibilità di accedere alla connessione WiFi, indispensabile per l'IoT, ma questo problema è stato risolto grazie ad un chip WiFi chiamato ESP8266 (si veda la sezione \ref{sec:esp8266} "ESP8266").

\begin{figure}
	\center{\includegraphics[width=0.4\linewidth]{./img/uno.jpg}}
	\caption{Scheda Arduino UNO}
	\label{fig:uno}
\end{figure}

%
\subsection{Arduino Programming Language}
%

La scheda Arduino UNO (e qualsiasi altra board compatibile con Arduino) può essere facilmente programmata utilizzando, ma non solo, l'Arduino IDE (Arduino Integrated Development Software), un software sviluppato da Arduino.cc e funzionante sulle 3 piattaforme dominanti (Windows, Linux e MacOS). Il linguaggio di programmazione si chiama "Arduino Programming Language"\cite{sistemi_embedded_atrent} ed è un derivato di Wiring (una piattaforma di sviluppo open-source composta da un linguaggio di programmazione, un IDE ed un circuito stampato basato su un microcontrollore). La sintassi è molto simile a quella del linguaggio C/C++; infatti il linguaggio Arduino è un insieme di funzioni e librerie C/C++ che possono essere chiamate dal codice. Forse la cosa diversa e che si nota di più rispetto ad altri linguaggi di programmazione è la diversa strutturazione dello sketch (sinonimo di programma): per poter funzionare vengono sempre definite due funzioni iniziali, setup() e loop(); la prima viene eseguita soltanto una volta all'avvio del programma e serve per dichiarare variabili, modalità dei pin (e.g input o output) ecc., mentre nella seconda viene messo il programma vero e proprio che viene eseguito ripetutamente... all'infinito.


%
\section{Real-time Clock}
%

I requisiti del progetto richiedono il salvataggio del log dopo ogni accesso avvenuto con successo, e per fare ciò è necessario essere in grado di tenere traccia del tempo. Il Raspberry Pi, diversamente dai PC a cui siamo abituati, può tenere traccia del tempo solo se ha accesso alla connessione Internet per accedere ad un server NTP (Network Time Protocol); nel progetto in questione, il Raspberry Pi, nonostante sia connesso alla rete LAN, è stato privato della connessione Internet per questioni di sicurezza (nessun utente esterno alla rete può accedere al server in locale perciò elimina gran parte degli attacchi possibili). Ciò significa che per poter avere il cosiddetto timestamp nei log bisogna trovare un modo di tenere traccia della data e dell'ora. Fortunatamente esistono dei piccoli chip chiamati RTC che fanno questo lavoro. 

Nella Figura \ref{fig:tinyRTC} si può vedere il dispositivo utilizzato nel progetto, chiamato TinyRTC, un modulo basato sul clock chip DS1307 (\url{https://datasheets.maximintegrated.com/en/ds/DS1307.pdf}) e supporta il protocollo I$^2$C (si veda la sezione \ref{sec:i2c} "I$^2$C") per cui è facilmente utilizzabile dall'Arduino UNO.
L'orologio può essere programmato con la data e l'ora corrente direttamente con il programma dell'Arduino e, grazie alla batteria al litio (CR1225), continua a tenere traccia del tempo anche senza alimentazione esterna. Il dispositivo è in grado di fornire, con abbastanza precisione, data e ora in termini di secondi, minuti, ora, giorno, mese e anno. Grazie alla popolarità di Arduino ci sono tante librerie per che permettono il facile utilizzo del dispositivo; nel progetto è stata usata una libreria chiamata RTClib che si può trovare nel seguente repository: \url{https://github.com/adafruit/RTClib}. Nella Figura \ref{fig:tinyRTC_uno} si può vedere il collegamento con l'UNO.

\begin{figure}
	\centering
	\begin{minipage}{0.5\textwidth}
		\centering
		\includegraphics[width=0.5\linewidth]{./img/tinyRTC.jpg}
		\captionof{figure}{Tiny RTC}
		\label{fig:tinyRTC}
	\end{minipage}%
	\begin{minipage}{0.5\textwidth}
		\centering
		\includegraphics[width=0.5\linewidth]{./img/tinyRTC_uno.png}
		\captionof{figure}{Tiny RTC e Arduino UNO}
		\label{fig:tinyRTC_uno}
	\end{minipage}
\end{figure}

%
\section{Trasmettitore-ricevitore RF}
%

Ci sono due principali tipi di tecnologie per i telecomandi: a raggi infrarossi o a radio-frequenza (RF).
La tecnologia a raggi infrarossi è quella più utilizzata ed è usata da tanti dispositivi elettronici (un esempio molto comune è il telecomando della TV). In questo caso trasmettitore e ricevitore devono essere messi "faccia-a-faccia" e non troppo distanti tra di loro, perciò non è il caso di usare questa tecnologia nel progetto (non si potrebbe, ad esempio, aprire la porta stando dietro ad un muro).

La tecnologia scelta è quindi quella a radio-frequenza, in cui trasmettitore e ricevitore possono comunicare anche se sono messi in camere diverse. Il dispositivo scelto (MX-05V/XD-RF-5V, Figura \ref{fig:rx_tx_module}) è un modulo composto da trasmettitore e ricevitore in radio-frequenza a 433 MHz (\url{https://sites.google.com/site/summerfuelrobots/arduino-sensor-tutorials/rf-wireless-transmitter-receiver-module-433mhz-for-arduino}). Il trasmettitore è stato utilizzato soltanto per programmare i telecomandi dell'azienda con i codici voluti grazie alla loro funzione di clonazione (codice sottostante).
\begin{lstlisting}
#include <RCSwitch.h>

int i = 0;
const char code[24] = "011100011011000110011010";
RCSwitch mySwitch = RCSwitch();

void setup() {
	Serial.begin(9600);
	mySwitch.enableTransmit(A0);
	mySwitch.setPulseLength(600);
	mySwitch.setProtocol(1);
}

void loop() {
	i = 0;
		while ( i<4) {
		mySwitch.send(code);
		i++;
		delay(400);
	}
	delay(3000);
}
\end{lstlisting}


Il ricevitore, invece, è sempre collegato all'Arduino (Figura \ref{fig:rf_uno}) e riesce a ricevere i segnali mandati dai telecomandi anche da qualche decine di metri di distanza. Se il codice che viene mandato dal telecomando è corretto allora l'Arduino lo risconosce e apre la porta, altrimenti fa finta di niente. 


Il ricevitore, per aumentare il range, è stato accoppiato con un'antenna lunga 17,3 cm. Il motivo di questa scelta è che la lunghezza dell'antenna deve essere 1/4 di quella della lunghezza d'onda. Bisogna quindi calcolare la lunghezza d'onda $\lambda$:
%
\[\lambda(m) = \frac{v(m/s)}{f(Hz)} = \frac{299,792,458}{433,000,000} = 0,692 m\] 
%
dove \textit{v} è la velocità della luce e \textit{f} è la frequenza (433 MHz). Ora si può trovare la lunghezza dell'antenna: 
%
\[\frac{\lambda}{4} = \frac{0,692}{4} = 0,173m = 17,3 cm \]
%

\begin{figure}
	\center{\includegraphics[width=0.3\linewidth]{./img/receiver_transmitter_module.jpg}}
	\caption{Modulo transceiver MX-05V/XD-RF-5V}
	\label{fig:rx_tx_module}
\end{figure}


\begin{figure}
	\center{\includegraphics[width=0.5\linewidth]{./img/rf_uno.png}}
	\caption{RF Receiver + Telecomando e Arduino UNO}
	\label{fig:rf_uno}
\end{figure}

\pagebreak

%
\section{Servomotore}\label{sec:servomotore}
%

Esistono tanti tipi diversi di motori Arduino-compatibili, ognuno con i propri punti forti e deboli, perciò bisogna valutare bene quale scegliere in base alle necessità del progetto. In questo caso il lavoro del motore è semplice: deve girare la serratura di una porta da una parte e dall'altra, quindi senza particolare precisione, velocità o potenza. Siccome non c'è nemmeno il bisogno di avere una rotazione completa (bastano 180$^{\circ}$), è immediato pensare al servomotore che è anche facilmente controllabile da un Arduino grazie ai suoi pin PWM e alla libreria Servo (\url{https://www.arduino.cc/en/reference/servo}).

Il servomotore (Figura \ref{fig:servo}) è un dispositivo elettromeccanico a basso consumo energetico ed è costituito da un motore DC, un gruppo di ingranaggi, un circuito di controllo (un ponte-H integrato) e un contenitore di plastica che lo racchiude.
La particolarità del servomotore è che può ruotare con una precisione di alcuni gradi (normalmente da 0$^{\circ}$ a 180$^{\circ}$) in base alla larghezza dell'impulso che riceve. Questa tecnica si chiama Pulse Width Modulation (PWM) e consiste in una serie di impulsi di larghezza variabile che determinano la posizione del servo.

\marginpar{\textbf{TO DO TO DO} se vuoi aggiungere, descrivi il funzionamento interno (potenziometro)} 

\begin{figure}
	\center{\includegraphics[width=0.15\linewidth]{./img/servo.png}}
	\caption{Servomotore}
	\label{fig:servo}
\end{figure}

%
\subsection{PWM}
%

\textbf{P}ulse \textbf{W}idth \textbf{M}odulation è una tecnica che consiste in una serie di impulsi di larghezza variabile che determinano la posizione del servo. E' quindi un modo di ricavare un risultato analogico a partire da un segnale digitale. Un segnale PWM ha una forma d'onda quadra, con periodo fisso, ma spesso non simmetrica: la durata della semi-onda alta può variare (si veda la Figura \ref{fig:pwm}). La durata \textit{T[ON]} del segnale alto viene misurata in percentuale e si chiama duty cycle: ad esempio un duty cycle del 25\% significa che \textit{T[ON]} dura per 1/4 della durata del periodo fisso \textit{T}. Questo tipo di segnale non è un vero e proprio segnale analogico, però può essere interpretato tale: quello che succede è che la tensione viene applicata e levata nel giro di frazioni di secondo perciò quello che si chiama "tensione efficace" è in realtà minore della tensione reale applicata. Per calcolare la tensione efficace \textit{Veff} basta sapere la tensione applicata \textit{Vcc} e il duty cycle \textit{DC} (che si trova facendo il rapporto tra \textit{T[ON]} e \textit{T}):

%
\[Veff = Vcc \cdot DC\]
%
Nel grafico della Figura \ref{fig:pwm} la \textit{Veff} è rappresentata dalla linea orizzontale che copre il segnale digitale.

\begin{figure}
	\center{\includegraphics[width=0.4\linewidth]{./img/pwm.png}}
	\caption{Segnali PWM e comando analogWrite(int value) per generarli con l'Arduino}
	\label{fig:pwm}
\end{figure}

Generalmente, nel caso dei servomotori, si ha un periodo totale \textit{T} = 20 ms, perciò ogni 20 ms il servo riceve un nuovo impulso. La posizione del motore dipende quindi dalla durata del tempo \textit{T[ON]} che questo impulso rimane ad un livello logico HIGH. Nel grafico della Figura \ref{fig:servo_pwm} si nota che la durata dell'impulso alto è un valore compreso tra 1ms (Duty Cycle = 5\%) e 2ms (Duty Cycle = 10\%). Fissata la posizione centrale del servo a 90$^{\circ}$, allora abbiamo che: 


\begin{figure}
	\center{\includegraphics[width=0.9\linewidth]{./img/servo_pwm.png}}
	\caption{Segnali PWM nel servomotore}
	\label{fig:servo_pwm}
\end{figure}


\begin{itemize}
	\item se la durata del livello logico HIGH dell'impulso sta nell'intervallo [1ms, 1.5ms] allora il servo ruota verso sinistra a partire dalla posizione centrale (la sua posizione varia tra 0$^{\circ}$ e 90$^{\circ}$)
	\item se la durata del livello logico HIGH dell'impulso è uguale a 1.5ms allora il servo resta fermo a 90$^{\circ}$
	\item se la durata del livello logico HIGH dell'impulso sta nell'intervallo [1.5ms, 2ms] allora il servo ruota verso destra a partire dalla posizione centrale (la sua posizione varia tra 90$^{\circ}$ e 180$^{\circ}$)
\end{itemize}


Controllare un servomotore con l'Arduino è in realtà semplice perché esiste una libreria (\url{https://www.arduino.cc/en/reference/servo}) che ne facilita il lavoro: basta pensare in gradi. Nella Figura \ref{fig:servo_uno} viene fatto vedere un esempio di collegamento tra il servo e l'Arduino e il codice per controllarlo si può trovare sotto.

\begin{lstlisting}
#include <Servo.h>

Servo myservo;
int pos = 0;

void setup() {
	myservo.attach(9);
}

void loop() {
	for (pos = 0; pos <= 180; pos += 1) {  
		myservo.write(pos);				 
		delay(15);                      
	}
	
	for (pos = 1800; pos >= 0; pos -= 1) {  
		myservo.write(pos);				   
		delay(15);                        
	}
}
\end{lstlisting}


\begin{figure}
	\center{\includegraphics[width=0.3\linewidth]{./img/servo_uno.png}}
	\caption{Servomotore e Arduino UNO}
	\label{fig:servo_uno}
\end{figure}

%
\section{RFID Reader}
%

\textbf{R}adio \textbf{F}requency \textbf{ID}entification (RFID) è un termine utilizzato per descrivere tecnologie contactless che fanno uso delle onde radio per identificare oggetti, persone e animali sia da vicino (tag passivi) che da lontano (tag attivi). L'identificazione è resa possibile grazie ad un lettore RFID in grado di interrogare i cosidetti tag, ovvero dei dispositivi elettronici di varie forme e dimensioni che possiedono i dati necessari per l'identificazione e che principalmente si dividono in due categorie: 

\begin{itemize}
	\item I tag passivi sono poco costosi e contengono un'antenna e un piccolo chip con identificativo univoco e privo di alimentazione. Questi tag vengono utilizzati per l'identificazione a breve distanza (qualche centimetro) e vengono "attivati" dalle onde radio del lettore.
	\item I tag attivi sono più costosi e permettono, grazie all'alimentazione interna (emettono loro stessi i segnali radio), l'identificazione a lunga distanza (fino a 200 metri).
\end{itemize}

La tecnologia RFID si diversifica anche nella frequenza utilizzata e trova utilizzo in tanti campi diversi quali gestione accessi, tracciabilità degli animali, gestione dei biglietti elettronici, ecc$.$ (per le basse e medie frequenze), ma anche in Telepass, identificazione di auto in movimento, tracciabilità degli oggetti in movimento ecc. (per le frequenze alte e altissime).

\begin{figure}
	\center{\includegraphics[width=0.35\linewidth]{./img/mfrc522.jpg}}
	\caption{Lettore RFID MFRC522}
	\label{fig:mfrc522}
\end{figure}

Il lettore RFID utilizzato nel progetto è il MFRC522 illustrato nella Figura \ref{fig:mfrc522} (\url{https://www.nxp.com/docs/en/data-sheet/MFRC522.pdf}). Esso opera su una frequenza di 13.56 MHz ed è in grado di comunicare con tag che si conformano allo standard ISO/IEC 14443 A/MIFARE. Implementa vari protocolli di comunicazione (SPI, Serial UART, I$^2$C) ma è stata sviluppata solo una libreria di Arduino (\url{https://github.com/miguelbalboa/rfid}) basata sul protocollo SPI (si veda la sezione \ref{sec:spi} "SPI").

Nella Figura \ref{fig:rfid_uno} si trova il circuito per collegare il lettore RFID con l'UNO e un esempio di codice di Arduino per leggere i tag si trova sotto.

\begin{lstlisting}
boolean rfidCardRead(void) {
	if ( !rfid.PICC_IsNewCardPresent() ) return false;
	if ( !rfid.PICC_ReadCardSerial() ) return false;
	currentCardNumber = "";
	for ( uint8_t i=0; i<5; i++ ) {
		currentCardNumber.concat(String(rfid.uid.uidByte[i], HEX));
	}
	currentCardNumber.toUpperCase();
	rfid.PICC_HaltA(); 
	return true;
}
\end{lstlisting} 

\begin{figure}
	\center{\includegraphics[width=0.65\linewidth]{./img/rfid_uno.png}}
	\caption{RFID + Tag e Arduino UNO}
	\label{fig:rfid_uno}
\end{figure}


%
\section{Display LCD 16x2}
%

I moduli LCD trovano ampio utilizzo nei sistemi embedded grazie al basso costo, disponibilità e utilità. Il display utilizzato si chiama "16x2 LCD" (Figura \ref{fig:16x2}) proprio perchè possiede uno schermo su cui si possono scrivere 2 linee di 16 caratteri ciascuna. Questi dispositivi sono abbastanza complessi (ci sono 1280 pixel da indirizzare) e per poterli utilizzare in maniera semplice ed efficiente è necessario avere un'interfaccia. Infatti i display LCD spesso vengono accoppiati con un controller che rende la vita facile al programmatore. Il controller più utilizzato (infatti è considerato uno standard \textit{de facto}) si chiama HD44780 (\url{https://www.sparkfun.com/datasheets/LCD/HD44780.pdf}), costruito dalla Hitachi, ed è in grado di controllare display LCD capaci di visualizzare solo caratteri. L'HD44780 supporta il trasferimento parallelo a 8 bit (possiede 8 bit di dati) e il suo compito principale è di ricevere i comandi e i dati in arrivo dall'MCU per poi processarli
e mandarli all'LCD.

\begin{figure}
	\center{\includegraphics[width=0.4\linewidth]{./img/16x2.jpg}}
	\caption{Display LCD 16x2}
	\label{fig:16x2}
\end{figure}

Il problema principale dell'LCD 16x2, come si può vedere nella Tabella \ref{tab:lcd_pinout}, è il numero di pin necessari da collegare (e la pazienza per farlo) all'Arduino per poter farlo funzionare correttamente. Questo significa che, siccome l'Arduino ha un numero limitato di pin (13 digitali e 6 analogici), essi potrebbero non bastare per un progetto di dimensioni più grandi. Fortunatamente c'è una soluzione: I$^2$C (si veda la sezione \ref{sec:i2c} "I$^2$C"). Esiste un chip che rende possibile la riduzione del numero di pin utilizzati a 2 (SDA e SCL) cambiando l'interfaccia parallela del controller in una seriale. Questo chip si chiama PCF8574 I/O Expander ed è definito come un backpack (è letteralmente uno "zaino" che si salda sopra l'LCD) e permette appunto all'LCD e all'Arduino di comunicare utilizzando il protocollo I$^2$C. Per utilizzarlo con Arduino esiste già una libreria che si chiama LiquidCrystal\_PCF8574 (\url{https://platformio.org/lib/show/1165/LiquidCrystal_PCF8574/installation}) che sfrutta la libreria Wire (\url{https://www.arduino.cc/en/Reference/Wire}) per implementare alcune funzioni utili al programmatore. Esempio di codice per utilizzare il LCD 16x2 con la libreria LiquidCrystal\_PCF8574:

\begin{lstlisting}
LiquidCrystal_PCF8574 lcd(lcdAddr); // lcdAddr = 0x27

void lcdSetup(void) {
	Wire.beginTransmission(lcdAddr);
	if ( Wire.endTransmission() == 0 ) Serial.println(F("LCD OK"));
	else Serial.println(F("LCD MISSING"));
	lcd.begin(16,2);
	lcd.noBlink();
	lcdHomeMode();
}

void lcdHomeMode(void) {
	lcd.setBacklight(0);
	lcd.clear();
}

\end{lstlisting}


\begin{table}[h!]
	\begin{center}
		\begin{tabular}{l|l} 
			\textbf{Pin} & \textbf{Funzione del pin} \\
			\hline
			1 & Vss (GND) \\
			2 & Vcc (5V) \\ 
			3 & Vee (Contrasto) \\
			4 & RS (Register Select: 0 per selezionare l'invio di un comando, 1 per i dati) \\
			5 & R/W (Read/Write: 0 per la scrittura di dati/comandi, 1 per la lettura dati/stato) \\
			6 & E (Enable bit: inizia il ciclo di scrittura o lettura) \\
			7 & D0 (Data 0) \\
			8 & D1 (Data 1) \\
			9 & D2 (Data 2) \\
			10 & D3 (Data 3) \\
			11 & D4 (Data 4) \\
			12 & D5 (Data 5) \\
			13 & D6 (Data 6) \\
			14 & D7 (Data 7) \\
			15 & A (Anodo (+): retroilluminazione) \\
			16 & K (Catodo (-): retroilluminazione) \\
		\end{tabular}
	\caption{Pinout di un display LCD 16x2 con il controller HD44780}
	\label{tab:lcd_pinout}
	\end{center}
\end{table}

%
\section{Keypad}
%

\begin{figure}
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{./img/keypad.jpg}
		\caption{Tastierino 4x4}
		\label{fig:keypad}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.78\linewidth]{./img/keypad_matrix.png}
		\caption{Rappresentazione a matrice dei pulsanti}
		\label{fig:keypad_matrix}
	\end{subfigure}
	\caption{Keypad}
	\label{fig:keypad_both}
\end{figure}

I tastierini sono dei dispositivi di input ampiamente utilizzati per dare la possibilità alle persone di interagire con un sistema (e.g$.$ inserire una password, controllare un robot ecc.). Normalmente i tasti sono disposti in un formato a matrice (in questo caso 4x4, ovvero 16 pulsanti) e permettono ad un microcontrollore di capire facilmente quale tasto è stato premuto in base alle linee che si attivano: nella Figura \ref{fig:keypad_both} si può facilmente vedere che premendo il pulsante "2" vengono attivate le linee "R0" e "C1" e il microcontrollore, grazie a come è stato configurato, è in grado di dire che quel pulsante specifico è stato premuto. Segue un esempio di configurazione in Arduino del tastierino (in questo caso non viene utilizzata l'ultima colonna con le lettere): 
\begin{lstlisting}
const byte keypadRows = 4;   // quattro righe
const byte keypadCols = 3;  // tre colonne
const byte keypadRowPins[keypadRows] = {5, 4, 3, 15}; // 15 = A1
const byte keypadColPins[keypadCols] = {8, 7, 6};
const char keypadConfig[keypadRows][keypadCols] =
{
{'1','2','3'},
{'4','5','6'},
{'7','8','9'},
{'*','0','#'}
};
\end{lstlisting}
Le funzioni per utilizzare il tastierino sono implementate nella libreria Keypad di Arduino (\url{https://playground.arduino.cc/Code/Keypad/}). Nella Figura \ref{fig:keypad_uno} si può vedere un esempio di collegamento tra il tastierino e l'Arduino UNO.


\begin{figure}
	\center{\includegraphics[width=0.5\linewidth]{./img/keypad_uno.png}}
	\caption{Keypad e Arduino UNO}
	\label{fig:keypad_uno}
\end{figure}


%
\section{ESP8266}\label{sec:esp8266}
%

L'Arduino UNO, a differenza di altre board più recenti, non ha il WiFi incorporato perciò bisogna accoppiarlo con uno shield che gli permette di avere quella funzionalità necessaria per un progetto IoT. Per questo progetto è stata scelta l'ESP8266, una famiglia di microchip WiFi a basso costo prodotta da Espressif Systems. Il dispositivo usato in realtà si chiama ESP-01 (Figura \ref{fig:esp01}), è basato sul modulo ESP8266 ed è prodotto da terze parti (Ai-Thinker). Questo piccolo modulo permette a microcontrollori di connettersi alla rete WiFi per fare semplici chiamate HTTP.
Tra le varie caratteristiche vengono elencate le più interessanti:

\begin{figure}
	\center{\includegraphics[width=0.2\linewidth]{./img/esp01.jpg}}
	\caption{L'ESP-01 di Ai-Thinker}
	\label{fig:esp01}
\end{figure}


\begin{itemize}
	\item basso costo e molto compatto
	\item antenna incorporata nel PCB
	\item 512 KB flash memory su cui caricare il programma
	\item 80 KB user data RAM
	\item può essere usato sia come Station che come Access Point (AP)
	\item implementa la funzione Deep Sleep per evitare il consumo eccessivo durante l'inattività
	\item può essere programmato attraverso l'IDE di Arduino
	\item implementa il protocollo IEEE 802.11 b/g/n
\end{itemize}
Il pinout e le funzioni dei pin si trovano rispettivamente nella Figura \ref{fig:esp_pinout_img} e nella Tabella \ref{tab:esp01_pinout}. 

L'ESP-01 va alimentato a una tensione di 3.3V ma secondo il datasheet (\url{http://www.microchip.ua/wireless/esp01.pdf}) potrebbe richiedere anche fino a 170mA di corrente perciò non si può alimentare direttamente dal piedino 3V3 dell'Arduino perchè non eroga abbastanza corrente (max 50 mA secondo \url{https://store.arduino.cc/arduino-uno-rev3}). Per questo motivo è stato usato il pin 5V dell'Arduino collegato ad un regolatore di tensione (LM1117, \url{http://www.ti.com/lit/ds/symlink/lm1117.pdf}). 
Il circuito si può trovare nella Figura \ref{fig:esp_uno}.

\vspace{\baselineskip}
\begin{minipage}{\textwidth}
	\begin{minipage}[b]{0.35\textwidth}
		\centering{\includegraphics[width=1\linewidth]{./img/esp_pinout_img.jpg}}	
		\captionof{figure}{ESP-01 Pinout}
		\label{fig:esp_pinout_img}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.65\textwidth}
		\centering
		\begin{tabular}{l|l}
			\textbf{Pin} & \textbf{Funzione del pin} \\
			\hline
			1 & RX (Receive data bit) \\
			2 & GPIO0 (General Purpose Input/Output Pin) \\
			3 & GPIO2 (General Purpose Input/Output Pin) \\
			4 & GND \\
			5 & VCC (+3.3V) \\
			6 & RST (Reset chip) \\
			7 & CH\_PD (Chip power-down) \\
			8 & TX (Transmit data bit) \\
		\end{tabular}
		\captionof{table}{Funzioni dei pin dell'ESP-01}
		\label{tab:esp01_pinout}
	\end{minipage}
\end{minipage}
\vspace{\baselineskip}

\begin{figure}
	\center{\includegraphics[width=0.7\linewidth]{./img/esp_uno.png}}
	\caption{ESP-01 e Arduino UNO}
	\label{fig:esp_uno}
\end{figure}


Il dispositivo viene pre-programmato con il firmware AT  (\url{https://www.electrodragon.com/w/ESP8266\_AT-Command\_firmware}) ma è possibile programmarlo anche con codice proprio (vedere la Tabella \ref{tab:esp01_modes} per le modalità di funzionamento) utilizzando l'IDE di Arduino. Segue una parte del codice caricato sull'ESP-01:

\begin{lstlisting}
#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include "wifi_secrets.h"

const char* ssid = SECRET_SSID;
const char* password = SECRET_PASS;

void setup () {

	Serial.begin(9600);
	WiFi.begin(ssid, password);
	Serial.print("Connecting");
	while (WiFi.status() != WL_CONNECTED) {
		delay(1000);
		Serial.print(".");
	}
	Serial.println("connected");
}
\end{lstlisting}
Come si può notare, all'accensione non fa altro che connettersi alla rete WiFi locale. La libreria utilizzata è molto bene documentata e si trova a \url{https://arduino-esp8266.readthedocs.io/en/latest/esp8266wifi/readme.html}.
Dopo aver effettuato la connessione, l'ESP-01 si mette in ascolto sulla porta seriale per dati in arrivo dall'Arduino per poi eseguire varie funzioni in base alla richiesta:
\begin{lstlisting}
void loop() {
	if ( WiFi.status() == WL_CONNECTED ) {
		if ( Serial.available() ) {
		String from_arduinoJSON = Serial.readString();
			if (from_arduinoJSON.startsWith("check")) {
				checkTesseraAPI(from_arduinoJSON.substring(5));
			}
			else if (from_arduinoJSON.startsWith("log")) {
				sendLogAPI(from_arduinoJSON.substring(3));
			}
		}
	}
}
\end{lstlisting}
\begin{table}[h!]
	\begin{center}
		\begin{tabular}{l|l} 
			\textbf{GPIO-0} & \textbf{Modalità} \\
			\hline
			GND & Flash mode (modalità programmazione) \\
			VCC & Normal mode (il chip esegue il codice caricato) \\
		\end{tabular}
		\caption{Modalità di funzionamento dell'ESP-01}
		\label{tab:esp01_modes}
	\end{center}
\end{table}
L'Arduino è programmato per mandare 2 tipi di richieste:

\begin{itemize}
	\item "check" per quando deve inoltrare all'ESP-01 il codice del tag per la verifica:
\begin{lstlisting}
boolean checkCardSerial(String serial) {
	boolean allowed = false;
	String bodyJSON = "check{\"seriale\":\"" + serial + "\"}";
	int statusCode = printBodyToESP(bodyJSON);
	...
}
\end{lstlisting}
	\item "log" per quando deve inoltrare all'ESP-01 un log:
\begin{lstlisting}
void sendLog(String tipo) {
	String date = getCurrentFormattedDate();
	String bodyJSON = "log{\"data\":\"";
	bodyJSON.concat(date);
	bodyJSON.concat("Z\",\"tipo\":\"" + tipo + "\"}\0");
	int statusCode = printBodyToESP(bodyJSON);
	if (statusCode == 200) Serial.println("Log sent");
	else Serial.println("Error code = " + String(statusCode));
}
\end{lstlisting}
\end{itemize}
In base alla richiesta vengono attivate 2 funzioni diverse:
\begin{itemize}
	\item una per mandare la verifica del tag al server tramite una chiamata HTTP:
\begin{lstlisting}
void checkTesseraAPI(String tesseraJSON) {
	HTTPClient http;
	http.begin("http://192.168.1.71:3000/api/tessere/check");
	http.addHeader("Content-Type", "text/plain");
	int statusCode = http.POST(tesseraJSON);
	delay(10);
	Serial.print(String(statusCode)); // send code to Arduino;
	http.end();
}
\end{lstlisting}
	\item una per mandare il log al server tramite una chiamata HTTP: 
\begin{lstlisting}
void sendLogAPI(String logJSON) {
	HTTPClient http;
	http.begin("http://192.168.1.71:3000/api/logs/add");
	http.addHeader("Content-Type", "text/plain");
	int statusCode = http.POST(logJSON);
	delay(10);
	Serial.print(String(statusCode)); // send code to Arduino;
	http.end();
}
\end{lstlisting}
\end{itemize}

\subsection{Comunicazione tra l'Arduino UNO e l'ESP-01 }

L'Arduino UNO è programmato per comunicare con l'ESP-01 tramite SoftwareSerial (https://www.arduino.cc/en/Reference/SoftwareSerial), una libreria che replica, per via software, le funzionalità della comunicazione seriale hardware (sui pin 0 e 1) anche su altri pin digitali. Esempio di codice per il setup della comunicazione seriale tra l'ESP-01 e l'Arduino UNO utilizzando SoftwareSerial:
\begin{lstlisting}
SoftwareSerial ESP(16, 17);

void arduinoEspSerialSetup() {
	ESP.begin(9600);
}
\end{lstlisting}
Come si è visto precedentemente, l'Arduino inoltra all'ESP-01 delle stringhe che sono quasi in formato JSON: prima dell'oggetto JSON c'è un'altra stringa usata per identificare la funzione voluta (e.g$.$ "check\{object\}" e "log\{object\}"). L'ESP-01 poi filtra questi dettagli non più necessari e chiama la funzione richiesta. Viene presentata la sequenza degli eventi per la verifica del tag:

\begin{enumerate}
	\item L'utente avvicina il tag al lettore RFID
	\item L'Arduino legge il seriale del tag e chiama "checkCardSerial(serial)"
	\item Questa funzione manda un'oggetto in formato quasi-JSON all'ESP-01
	\item L'ESP-01 riceve questa stringa e filtra l'informazione non più necessaria
	\item L'ESP-01 chiama la funzione richiesta (in questo caso "checkTesseraAPI(tesseraJSON)")
	\item La funzione eseguita manda l'oggetto JSON al server e aspetta una risposta con lo status code.
	\item L'ESP-01 inoltra lo status code all'Arduino
	\item L'Arduino prende una decisione un base allo Status Code: se 200 allora il tag è accettato e l'Arduino apre la porta, altrimenti viene rifiutato.
\end{enumerate}
Come si può vedere dalla sequenza degli eventi, l'ESP-01 non è altro che un intermediario tra l'Arduino e il server.
%
\section{Protocolli di comunicazione tra dispositivi}
%
%
\subsection{Logica IoT}
%
\textbf{Da fare come riempimento?}

%
\subsection{I$^2$C}\label{sec:i2c}
%

\begin{figure}
	\center{\includegraphics[width=0.6\linewidth]{./img/i2c_bus.png}}
	\caption{I$^2$C Bus}
	\label{fig:i2c_bus}
\end{figure}

\textbf{I}nter \textbf{I}ntegrated \textbf{C}ircuit è un protocollo seriale a due vie inventato dalla NXP per far comunicare tra di loro dispositivi come microcontrollori, memorie EEPROM, dispositivi di input/output ecc. E' un protocollo creato per la comunicazione sincrona e a breve distanza tra dispositivi chiamati dispositivi master e slave (Figura \ref{fig:i2c_bus}): 

\begin{itemize}
	\item Lo slave è un dispositivo che riceve i comandi dal master. Ogni slave ha un indirizzo (deve essere unico all'interno del sistema) normalmente specificato nel datasheet (e.g$.$ per il display LCD 16x2 con il backpack PCF8574 utilizzato nel progetto l'indirizzo è 0x27) attraverso il quale viene indirizzato dal master.
	\item Il master non ha bisogno di un indirizzo ed è quello che genera il clock (per via di SCL). Il suo compito è di fare partire la comunicazione con i slave e inviare comandi di lettura/scrittura. Un sistema può avere più dispositivi master.
\end{itemize}
I$^2$C è un protocollo a due vie perchè utilizza due linee bidirezionali:

\begin{itemize}
	\item SDA (\textbf{S}erial \textbf{Da}ta) attraverso il quale viaggiano i dati. I dati vengono trasferiti in \textit{messaggi} che vengono divisi in blocchi di dati a 8 bit. Ogni messaggio parte con il "Start Condition" e finisce con "Stop Condition" e ha al suo interno, oltre ai blocchi di dati, l'indirizzo dello slave con cui il master desidera comunicare. Per gestire i comandi di lettura/scrittura è presente un Read/Write bit. Nel messaggio vengono inclusi anche i cosidetti ACK/NACK (acknowledge/no-acknowledge) bit che vengono mandati dal destinatario (lo slave in modalità "write", il master in modalità "read") dei blocchi di dati inviati. Un esempio di messaggio si trova nella Figura \ref{fig:i2c_data_bus}. 
	\item SCL (\textbf{S}erial \textbf{Cl}ock) utilizzato dal master per la sincronizzazione.
\end{itemize}

\begin{figure}
	\center{\includegraphics[width=1\linewidth]{./img/i2c_data_bus.png}}
	\caption{Esempio di messaggio inviato sulla linea SDA nel protocollo I$^2$C }
	\label{fig:i2c_data_bus}
\end{figure}


%
\subsection{SPI}\label{sec:spi}
% 

\textbf{S}erial \textbf{P}eripheral \textbf{I}nterface è un protocollo di comunicazione sincrona inventato dalla Motorola e ampiamente utilizzato nei sistemi embedded. Similmente al protocollo I$^2$C, è stato creato per la comunicazione a breve distanza tra un dispositivo master (in questo caso può essere uno solo) e uno o più slave.
SPI è basato su 4 segnali (4-wire bus):

\begin{itemize}
	\item SCLK (\textbf{S}erial \textbf{Cl}oc\textbf{k}) utilizzato dal master per la sincronizzazione.
	\item MISO (\textbf{M}aster \textbf{I}nput \textbf{S}lave \textbf{O}utput) collegato all'input del master e all'output degli slave. Viene utilizzata dagli slave per inviare dati al master.
	\item MOSI (\textbf{M}aster \textbf{O}utput \textbf{S}lave \textbf{I}nput) collegato all'output del master e all'input degli slave. Viene utilizzata dal master per inviare dati allo slave.
	\item CS (\textbf{C}hip \textbf{S}elect) utilizzato per selezionare lo slave che deve essere abilitato alla comunicazione con il master. Il master può selezionare lo slave con cui vuole parlare semplicemente mettendo a LOW il segnale CS dello slave.
\end{itemize}
Anche se sembrano molto simili, ci sono alcune differenze importanti tra i due protocolli presentati che li rendono adatti per varie applicazioni. Le differenze vengono descritte nella Tabella \ref{tab:i2c_vs_spi}.

\begin{table}[h!]
	\centering
	\begin{tabularx}{\linewidth}{|L|L|}
		\hline 
		\textbf{I$^2$C} & \textbf{SPI} \\ 
		\hline
		Può avere più master & Può avere un singolo master \\ 
		\hline
		Protocollo a 2 vie & Protocollo a 4 vie (+1 per ogni slave addizionale) \\ 
		\hline
		Velocità fino a 3.4 Mbps in modalità High Speed &  Velocità illimitata (normalmente implementata tra 10 e 100 Mbps) \\ 
		\hline
		Massimo 112 dispositivi con indirizzamento a 7-bit & Limitato dal numero di pin CS del master \\ 
		\hline
		Half-duplex & Full-duplex \\ 
		\hline
	\end{tabularx}
	\caption{I$^2$C vs SPI\cite{i2c_vs_spi}}
	\label{tab:i2c_vs_spi}
\end{table}

%			CAPITOLO 3
\chapter{Sviluppo del sito web}
\label{cap3}
%

In questo capitolo vengono descritte le tecnologie e le scelte progettuali che hanno portato allo sviluppo dell'interfaccia grafica richiesta dai requisiti per la gestione del database dell'azienda (si veda la sezione \ref{sec:req} "Requisiti del progetto"). Nella Figura \ref{fig:esempio_libro_soci} si può vedere un esempio della grafica creata per la gestione del libro soci.

\begin{figure}
	\center{\includegraphics[width=0.77\linewidth]{./img/esempio_libro_soci.png}}
	\caption{Screenshot fatto durante la fase di test del sito web}
	\label{fig:esempio_libro_soci}
\end{figure}


%
\section{Back-End}

In ingegneria del software, il termine back-end rappresenta il lato server di un'applicazione, ovvero un programma che si occupa dei dati dell'applicazione con i quali un utente interagisce indirettamente tramite il front-end. Generalmente il back-end è implementato utilizzando Javascript (Node.js), Python, PHP o Ruby.

\subsection{Scelte progettuali}

\subsubsection*{Node.js}

Node.js è un framework open-source che esegue codice JavaScript al di fuori da un browser. E' basato sul motore JavaScript V8 di Google ed è stato creato per rendere possibile la creazione di un server utilizzando un linguaggio di programmazione con la stessa sintassi di JavaScript (si parla del paradigma "JavaScript-everywhere"). Vengono elencati alcuni vantaggi principali di Node.js

\begin{itemize}
	\item rende possibile la programmazione ad eventi (un approccio asincrono): un'azione viene lanciata solo quando succede qualcosa (un evento) e non perforza nell'ordine del codice scritto, aumentando l'efficienza soprattutto nell'ambito di networking dove capita spesso dover rimanere in attesa di una risposta;
	\item scalabilità del software;
	\item NPM (Node Package Manager): è il più grande ecosistema di librerie open source al mondo. Infatti Node.js ha un enorme quantità disponibile di librerie scritte da altri sviluppatori e possono essere installati facilmente utilizzando NPM;
	\item utilizza lo stesso linguaggio di programmazione degli sviluppatori front-end, perciò è ancora piu' semplice diventare un full-stack developer grazie al fatto di non dover perforza conoscere linguaggi come Ruby o PHP.
\end{itemize}

L'applicazione utilizza vari moduli di Node.js:

\begin{itemize}
	\item Path (\url{https://nodejs.org/docs/latest/api/path.html}) fornisce alcune utilità nel lavorare con i file e con i percorsi delle directory. L'applicazione usa il modulo per definire una directory statica assoluta per i file dell'applicazione senza dover quindi utilizzare l'intero indirizzo della directory "public": 
\begin{lstlisting}
app.use(express.static(path.join(__dirname, 'public')));
\end{lstlisting}
	\item Express (\url{https://expressjs.com/}) è un framework robusto e flessibile che fornisce un insieme di funzioni che facilitano e velocizzano lo sviluppo di applicazioni web con Node.js. L'applicazione fa uso di express per:
	\begin{itemize}
		\item definire delle middleware per rispondere a richieste HTTP e per gestire gli errori. Esempio di middleware per caricare la pagina "404.ejs" nel caso in cui un utente provi ad accedere ad una pagina non esistente:
\begin{lstlisting}
// Catch 404 and forward to error handler

app.use(function(req, res, next) {
	var err = new Error('Not Found');
	err.status = 404;
	next(err);
});
	
app.use(function(err, req, res, next) {

// render the error page
	if (err.status === 404) res.render('404');
	else { // other types of errors
		res.status(err.status || 500);
		res.render('error');
	}
});
\end{lstlisting}
		\item definire una tabella di routing (lista di endpoint) che viene usata per eseguire diverse azioni in base all'URL e al tipo di richiesta HTTP. Un esempio di utilizzo è: 	
\begin{lstlisting}
app.get('/', (req, res) => res.render('index'));
\end{lstlisting}
		Quando viene fatta una richiesta GET all'endpoint "/" allora, come risposta, l'applicazione invia all'utente un file chiamato "index.ejs" (che rappresenta la homepage) che viene poi caricato dal suo browser;
		\item caricare pagine HTML in maniera dinamica passando degli argomenti ai template (e.g. usando un linguaggio di templating chiamato EJS);
		\item si possono creare in maniera semplice e veloce delle API RESTful (si veda la sezione \ref{sec:api});
		\item interfacciarsi con vari database (e.g. MongoDB, MySQL ecc.)
		\item creare un server che ascolta su una porta preimpostata (fornisce un'astrazione del modulo \emph{http} di Node.js):
\begin{lstlisting}
var server = app.listen(port, () => {
	console.log("Listening on port " + server.address().port);
});
\end{lstlisting}   
	\end{itemize}
	\item Body-Parser (\url{https://www.npmjs.com/package/body-parser}) ispeziona i contenuti delle richieste HTTP. Utile per poter leggere i dati in formato JSON (e non solo). 
\begin{lstlisting}
// for parsing
app.use(bodyParser.json()); 
app.use(bodyParser.urlencoded( { extended: true } )); 
app.use(bodyParser.text()); 
\end{lstlisting}
	\item EJS (\url{https://ejs.co/}) è un linguaggio di templating che permette di avere dati provenienti dal server direttamente all'interno di documenti HTML. Il codice nel lato server è molto semplice: 
\begin{lstlisting}
app.set('view engine', 'ejs');
\end{lstlisting}
Esempio di utilizzo nel lato client (il codice JavaScript all'interno della pagina HTML è racchiuso tra "$<$\% \%$>$" e l'oggetto "tessere" è stato passato dal server in formato JSON):
\begin{lstlisting}[language=HTML]
<% for(var i=0; i<tessere.length; i++) { %>
	<tr class="w3-black tessere-table-mobile">
		<td><%= tessere[i].numero_tessera %></td>
		<td><%= tessere[i].seriale %></td>
		<td><%= dateFormat(tessere[i].rilasciato.toLocaleString("it-IT", { "year": "numeric", "month": "2-digit", "day": "2-digit" })) %></td>
		<td><%= dateFormat(tessere[i].ultimo_rinnovo.toLocaleString("it-IT", { "year": "numeric", "month": "2-digit", "day": "2-digit" })) %></td>
		<% if ( tessere[i].stato === "ATTIVATA" ) { %>
			<td>
				<div class="green-circle" style="margin: auto;"></div>
			</td>
		<% } else { %>
			<td>
				<div class="red-circle" style="margin: auto;"></div>
			</td>
		<% } %>
	</tr>
<% } %>
\end{lstlisting}
	\item Mongoose (\url{https://mongoosejs.com/}) è una libreria di ODM (\textbf{O}bject \textbf{D}ata \textbf{M}odeling) che fornisce un ambiente per la modelizzazione dei dati di MongoDB permettendo la definizione degli oggetti sotto uno schema fortemente tipizzato (si veda la sezione \ref{sec:db} "Database")	
\end{itemize}

\subsubsection*{MVC}

\begin{figure}
	\center{\includegraphics[width=0.4\linewidth]{./img/mvc.png}}
	\caption{Esempio delle interazioni tra i componenti del pattern MVC}
	\label{fig:mvc}
\end{figure}

Per garantire l'indipendenza tra i dati e l'interfaccia, si può modularizzare il codice: il sistema viene diviso in moduli, in modo che esso risulti più semplice da comprendere e da manipolare. La modularizzazione è necessaria soprattutto quando aumenta la complessità di un progetto (che deve essere scalabile) poichè garantisce che ogni parte sia modificabile, estendibile e riutilizzabile.
Il sito web è stato creato sulla base di MVC (Model-View-Controller), un pattern architetturale (Figura \ref{fig:mvc}) che separa un'applicazione in tre principali componenti logici: il modello, la vista e il controller. Ognuno di questi componenti è progettato per gestire diversi aspetti specifici dello sviluppo di un'applicazione:

\begin{itemize}
	\item Il modello corrisponde alla struttura e alla logica dei dati dell'applicazione. Esempio che descrive il modello dei log:
\begin{lstlisting}
var mongoose = require('mongoose');
var Schema = mongoose.Schema;

var LogSchema = new Schema (
{
	tipo: { type: String, enum: ["telecomando", "tessera", "keypad"], required: true, lowercase: true, trim: true },
	seriale: { type: String, default: "N/A", uppercase: true, trim: true },
	nome: { type: String, default: "N/A", lowercase: true, trim: true },
	cognome:  { type: String, default: "N/A", lowercase: true, trim: true },
	numero_tessera: { type: String, default: ""},
	data: { type: Date, required: true }
});

LogSchema.index( { '$**': 'text'}); // full-table search index

/* 
 *	Tutte le stringhe vengono incluse nell'indice.
 *	Permette di fare le query in questo modo: 
 *	Log.find( { $text: { $search: searchTerm }}) 
 */

// export function to create "Log" model class
module.exports = mongoose.model("Log", LogSchema);
\end{lstlisting}
	\item La vista corrisponde alla logica dell'UI (\textbf{U}ser \textbf{I}nterface) dell'applicazione. Rappresenta il modo in cui vengono presentati i dati all'utente. Come esempio viene esposta una parte del codice HTML della vista creata per presentare le tessere all'utente:
\begin{lstlisting}
<table class="w3-table w3-left w3-border w3-centered">
	<thead>
		<tr class="w3-white tessere-table-mobile w3-large">
			<th>Numero tessera</th>
			<th>Seriale</th>
			...
		</tr>
	</thead>
	<tbody>
		<% for(var i=0; i<tessere.length; i++) { %>
			<tr class="w3-black tessere-table-mobile">
				<td><%= tessere[i].numero_tessera %></td>
				<td><%= tessere[i].seriale %></td>
				...
			</tr>
	</tbody>
</table>
\end{lstlisting}
	\item Il controller accetta l'input dell'utente (e.g. visitare il sito web, cliccare su un pulsante, inviare un modulo ecc.) e lo trasforma in comandi per il modello o per la vista. Esempio di una parte del codice del controller creato per gestire i comandi relativi ai soci:
\begin{lstlisting}
exports.fullTableSearch = (req, res) => {
	let searchTerm = req.params.term;
	Socio.
	find( { $text: { $search: searchTerm } } ).
	exec(function(err, soci) {
		if (err) {
			console.error(err);
			return res.status(500).send("Internal Server Error");
		} else return res.render("../views/soci/soci_index", { searched: "true", soci: soci, sociString: JSON.stringify(soci) });
	});
}
\end{lstlisting}
	 Questa funzione, quando viene chiamata, cerca nel database i soci in base al termine inviato tra i parametri e poi carica una pagina con i risultati.
\end{itemize}


\subsection{Database}\label{sec:db}
%
Il DBMS (\textbf{D}ata\textbf{B}ase \textbf{M}anagement \textbf{S}ystem) scelto per l'applicazione si chiama MongoDB (\url{https://www.mongodb.com/}). MongoDB è un DBMS open source e non relazionale (classificato come un database di tipo NoSQL) ed è orientato ai documenti: al posto delle tipiche tabelle dei database relazionali vengono utilizzati dei documenti in formato JSON, facilitando quindi l'integrazione dei dati con quasi tutte le applicazioni web (infatti JSON è il formato di dati più utilizzato per lo scambio dei dati in rete).
MongoDB si integra facilmente con Node.js grazie a dei driver creati dagli sviluppatori stessi (\url{https://mongodb.github.io/node-mongodb-native/3.2/}). Questi driver, purtroppo, non portano tanta astrazione e sollevano dei problemi per chi non è abituato a un database NoSQL: 
\begin{itemize}
	\item la logica dei dati è diversa rispetto a quella che viene insegnata nei corsi tradizionali di basi di dati perciò potrebbe essere difficile abituarsi (ma, come si vedrà, anche non necessario);
	\item non c'è la possibilità di validare i dati in maniera semplice ma bisogna scrivere del codice che potrebbe essere soggetto a errori;
	\item le query con i driver nativi di MongoDB non sono tanto leggibili e possono diventare molto complesse perchè usano un insieme di operatori (e.g. quello di uguaglianza "\$eq"). Esempio:
\begin{lstlisting}
Account.find({ nome: { $eq: 'Andrea' } });
\end{lstlisting}
	\item la manutenzione è resa più complicata per la mancanza di una struttura fissa dei dati.
\end{itemize}

E' possibile però avere più astrazione (ad un basso costo di performance) utilizzando Mongoose, una libreria basata sui driver di MongoDB ideata per la modellazione degli oggetti di MongoDB e progettata per funzionare in un ambiente asincrono (come Node.js). Mongoose rende più semplice e immediato l'utilizzo di MongoDB per alcuni motivi:
\begin{itemize}
	\item facilità di apprendimento;
	\item query più semplificate e leggibili grazie al "method chaining" di JavaScript (soprattutto quando diventano complesse). Ad esempio:
\begin{lstlisting}
exports.updateSocio = (req, res) => {
	Socio.
	findOne( { _id: req.params.id } ).
	exec( (err, socio) => {
		if (err) {
			console.error(err);
			return res.status(500).send("Internal Server Error");
		} else return res.render("../views/soci/soci_update", { socio: socio });
	});
};
\end{lstlisting}
	\item fornisce un modo per dare una struttura ai dati grazie alla creazione degli schemi; ogni schema può essere compilato in un modello, ovvero una classe con cui vengono costruiti i documenti con i comportamenti (metodi) e le proprietà (attributi) dello schema dato;
	\item permette di validare i dati all'interno degli schemi (e.g. attributo: \{ type: String, lowercase: true \});
	\item libreria progettata per un ambiente asincrono: è possibile definire delle middleware (pre, post) da chiamare prima o dopo una certa operazione (e.g. di salvataggio). Ad esempio:
\begin{lstlisting}
var schema = new Schema(..);
schema.pre('save', function(next) {
	// do stuff
	next(); // chiama il prossimo middleware
});
\end{lstlisting}
\end{itemize}
Come esempio, viene presentata la sequenza degli eventi per aggiungere un log (dopo un accesso con la tessera) all'interno del database e poi visualizzarlo sul sito:
\begin{enumerate}[(I)]
	\item L'Arduino manda una richiesta di aggiunta del log all'endpoint \emph{/api/logs/add} del server tramite l'ESP-01:
\begin{lstlisting}
void sendLogAPI(String logJSON) {
	HTTPClient http;
	http.begin("http://192.168.1.71:3000/api/logs/add");
	http.addHeader("Content-Type", "text/plain");
	int statusCode = http.POST(logJSON); // HTTP POST request
	delay(10);
	Serial.print(String(statusCode)); // invia all'Arduino
	http.end();
}
\end{lstlisting}
	\item L'applicazione, dopo aver ricevuto una richiesta POST all'endpoint specificato precedentemente, chiama una funzione per gestire la richiesta:
\begin{lstlisting}
app.post('/api/logs/add', logs.addLog);
\end{lstlisting}
	\item La funzione gestisce la richiesta e salva il log nel database:
\begin{lstlisting}
exports.addLog = (req, res) => {
	var body = JSON.parse(req.body);
	... // alcune righe di codice per validare i dati
	if (body.tipo === "tessera") { // log con tessera 
		Tessera.
		findOne( { seriale: body.seriale } ). // trova la tessera 
		populate('socio').
		exec( (err, tessera) => {
			if (err) return console.error(err);
			if (tessera) {
				let log = new Log ({
					nome: tessera.socio.nome,
					cognome: tessera.socio.cognome,
					numero_tessera: tessera.numero_tessera,
					seriale: tessera.seriale,
					data: date,
					tipo: body.tipo
				});	
				log.save( (err) => {
					if (err) console.error(err);
					else {
						console.log("Log aggiunto");
						return res.status(200).send();
					}
				});
			} else return res.status(404).send("Not Found");
		});
	} else { ... } // log senza tessera
}
\end{lstlisting}
\item Il log è visualizzabile sul sito accedendo all'endpoint \emph{/api/logs/view} (il risultato si può vedere nella Figura \ref{fig:logbook})$.$ Esempio del codice eseguito dopo una richiesta GET all'endpoint specificato:
\begin{lstlisting}
exports.viewAllLogs = (req, res) => {
	Log.find( (err, logs) => {
		if (err) {
			console.error(err);
			return res.status(500).send("Internal Server Error");
		}
		else return res.render("../views/logs/logs_index", { logs: logs });
	});
}
\end{lstlisting}
\end{enumerate}

\begin{figure}
	\center{\includegraphics[width=0.8\linewidth]{./img/logbook.png}}
	\caption{Il logbook dell'azienda}
	\label{fig:logbook}
\end{figure}

Il ragionamento per aggiungere i soci e le tessere al database è simile, solo che si può fare direttamente dal sito: il browser manda i form compilati (esempio nella Figura \ref{fig:add_tessera_form}) tramite una richiesta POST al server. Per ogni tipo di richiesta diversa, verrà chiamata una funzione specifica per gestirla.
 
\begin{figure}
	\center{\includegraphics[width=0.8\linewidth]{./img/add_tessera_form.png}}
	\caption{Form da compilare per aggiungere una tessera nel database}
	\label{fig:add_tessera_form}
\end{figure}

\subsection{RESTful API}\label{sec:api}
%
Le API (\textbf{A}pplication \textbf{P}rogramming \textbf{I}nterface) in ambito web sono un insieme di specificazioni per far comunicare tra di loro client (generalmente il browser) e server tramite richieste e risposte HTTP. Vengono specificati e descritti gli endpoint, i tipi di richiesta (e.g. GET/POST/UPDATE/DELETE) e i tipi di risposta (struttura dei dati inviati, messaggi di errore ecc.).
Le API RESTful sono basate su tecnologia REST (\textbf{RE}presentational \textbf{S}tate \textbf{T}ransfer), uno stile architetturale spesso usata nello sviluppo delle applicazioni web. Il concetto più importante in REST è l'esistenza di risorse a cui si possono accedere tramite identificatori univoci (URI - \textbf{U}niform \textbf{R}esource \textbf{I}dentifier), ovvero gli endpoint.
Tipicamente le API RESTful sfruttano le chiamate HTTP per dare la possibilità a utenti di leggere (GET), aggiornare (PUT), creare (POST) e rimuovere (DELETE) risorse. 

Un elenco delle API dell'applicazione si può trovare nella Tabella \ref{tab:api}.
Le API sono state testate con Postman (\url{https://www.getpostman.com/}), un software progettato per lo sviluppo e il testing delle API web. Postman dà la possibilità allo sviluppatore di creare diversi tipi di richieste HTTP da inviare ad un URL. Un esempio di utilizzo di Postman si può trovare nella Figura \ref{fig:postman_test}.

\begin{table}[H]
	\scriptsize
	\centering
	\renewcommand\arraystretch{1.8}
	\renewcommand\tabcolsep{3.0pt}
	\begin{tabularx}{\textwidth}{|L|L|L|L|}
		\hline
		\textbf{Metodo + URI} & \textbf{Parametro} & \textbf{Body} & \textbf{Descrizione} \\
		\hline                              
		GET / & N/A & N/A & Carica la homepage \\ 
		\hline
		GET /api/logs/search/:key & Chiave per la ricerca & N/A 
		& Cerca nel database dei log in base al parametro inviato e carica la pagina con i risultati \\
		\hline
		GET /api/logs/view & N/A & N/A & Carica la pagina con tutti i log \\
		\hline  
		POST /api/logs/add & N/A & Oggetto in formato JSON secondo lo schema Log & Aggiunge un log nel database \\
		\hline
		GET /api/soci/search/:key & Chiave per la ricerca & N/A & Cerca nel database dei soci in base al parametro inviato e carica la pagina con i risultati \\ 
		\hline
		GET /api/soci/view & N/A & N/A & Carica la pagina con tutti i log \\ 
		\hline
		GET /api/soci/create & N/A & N/A & Carica la pagina per creare i soci \\ 
		\hline
		GET /api/soci/update/:id & Chiave identificativa del socio & N/A & Carica la pagina per aggiornare un socio \\ 
		\hline
		POST /api/soci/add & N/A & Oggetto in formato JSON secondo lo schema Socio & Aggiunge un socio nel database \\ 
		\hline
		PUT /api/soci/update/:id & Chiave identificativa del socio & Oggetto in formato JSON secondo lo schema Socio & Aggiorna un socio \\ 
		\hline
		DELETE /api/soci/delete/:id & Chiave identificativa del socio & N/A & Cancella un socio dal database \\ 
		\hline
		GET /api/tessere/view & N/A & N/A & Carica la pagina con tutte le tessere \\ 
		\hline
		POST /api/tessere/check & N/A & Oggetto in formato JSON secondo lo schema Tessera & Verifica se un tag esiste nel database \\
		\hline
		POST /api/tessere/add & N/A & Oggetto in formato JSON secondo lo schema Tessera & Aggiunge una tessera \\ 
		\hline
		PUT /api/tessere/update/:id & Chiave identificativa della tessera & N/A & Cambia lo stato di una tessera (attiva/disattiva) \\ 
		\hline
		DELETE /api/tessere/delete/:id & Chiave identificativa della tessera & N/A & Cancella una tessera dal database \\ 
		\hline
	\end{tabularx}
	\captionsetup{font={footnotesize}}
	\caption{Specificazione delle API dell'applicazione}
	\label{tab:api}
\end{table}    

\begin{figure}
	\center{\includegraphics[width=1\linewidth]{./img/postman_test.png}}
	\caption{Esempio di testing con Postman dell'endpoint relativo all'aggiunta dei log}
	\label{fig:postman_test}
\end{figure}

%
\section{Front-End}
%

In ingegneria del software, il termine front-end rappresenta l'interfaccia dell'applicazione, ovvero la parte visibile agli utenti e quella con cui essi interagiscono.

%
\subsection{Scelte progettuali}
%

Per creare il front-end vengono utilizzati linguaggi come HTML (per la struttura e contenuto), CSS (per lo stile) e client-side JavaScript per aggiungere dinamicità al sito (pulsanti, chiamate AJAX ecc.).

%
\subsubsection*{HTML5}
%
\textbf{H}yper \textbf{T}ext \textbf{M}arkup \textbf{L}anguage è il linguaggio di markup standard nato all'inizio degli anni novanta per la formattazione e impaginazione di documenti progettati per essere visualizzati in un browser. E' stato sviluppato assieme al protocollo HTTP dedicato al trasferimento di documenti di tale formato. Viene spesso utilizzato insieme ad un linguaggio di stile (CSS) e uno di scripting (JavaScript). L'ultima versione standardizzata dal W3C è HTML 5.1.
I file HTML generati nel progetto hanno l'estensione EJS perchè vengono usati assieme al linguaggio di templating per portare i dati provenienti dal server direttamente nel documento stesso.
%
\subsubsection*{CSS}
%
I documenti HTML sono stilizzati con il linguaggio di stile più diffuso al mondo chiamato CSS (\textbf{C}ascading \textbf{S}tyle \textbf{S}heets): esso descrive, attraverso delle regole, i modi in cui gli elementi di un documento devono essere presentati e animati nell'interfaccia grafica. Le regole possono essere scritte direttamente nel file HTML, ma ciò crea solo confusione ed è generalmente buona norma avere i file CSS separati e poi importati nel documento, così come segue:
\begin{lstlisting}
<link rel="stylesheet" href="/css/w3.css">
<link rel="stylesheet" href="/css/custom.css">
<link rel="stylesheet" href="/css/font-awesome.min.css">
\end{lstlisting}
Normalmente gli sviluppatori non scrivono le proprie regole (è un lavoro molto lungo e per fare una cosa bella serve tanta esperienza in web design) ma trovano dei template (esistono sia gratis che a pagamento) da utilizzare. In questo caso è stato utilizzato un template (\url{https://www.w3schools.com/w3css/tryw3css_templates_dark_portfolio.htm}) di W3.CSS (\url{https://www.w3schools.com/w3css/default.asp}) scelto dal tutor aziendale. W3.CSS è un framework moderno, semplice, veloce e gratis che supporta un design mobile-first che aiuta lo sviluppatore a creare siti web moderni e responsivi. Il vantaggio di un sito responsivo è il fatto che è stato progettato per rispondere automaticamente a tutti i tipi di dispositivi utilizzati per visualizzarlo (e.g. desktop, mobile, tablet). Questo approccio viene implementato sfruttando le caratteristiche delle \emph{media queries}:
\begin{lstlisting}
@media (max-width:768px)
{
	.red-circle
	{
		width: 25px!important;
		height: 25px!important;
	}
	
	.green-circle
	{
		width: 25px!important;
		height: 25px!important;
	}
}
\end{lstlisting}
Inoltre è stato utilizzato \emph{Font Awesome}, un toolkit di icone distribuito sotto licenze libere (CC BY 4.0 e MIT).
%
\subsubsection*{JavaScript}
%
JavaScript è un linguaggio di programmazione introdotto nel 1995 con lo scopo di aggiungere programmi all'interno di siti web sul browser Netscape Navigator. Il linguaggio è stato adottato da quasi tutti gli altri browser esistenti (è stato anche standardizzato sotto il nome di ECMAScript) e ha reso possibile avere applicazioni web moderne con cui un utente può interagire direttamente senza dover ricaricare la pagina\cite{eloquent_javascript}. E' un linguaggio molto evoluto e studiato nel tempo e ora si definisce come un linguaggio di scripting client-side (ma non solo, come si è visto con Node.js) eseguito dai browser. Il codice JavaScript può essere scritto all'interno di qualsiasi documento, ma è buona norma avere i file con estensione .js separati e poi inclusi alla fine del documento (per far sì che tutti gli elementi vengano caricati dal browser), così come segue: 
\begin{lstlisting}
<script type="text/javascript" src=/js/jquery-3.3.1.min.js></script>
<script type="text/javascript" src=/js/forms.js></script>
<script type="text/javascript" src=/js/buttons.js></script>
<script type="text/javascript" src=/js/dettagliSoci.js></script>
\end{lstlisting}
JavaScript è un linguaggio che utilizza un singolo thread (organizza l'esecuzione in un'unica pila chiamata \emph{call stack}) e segue il paradigma della programmazione a eventi, perciò è possibile costruire un comportamento non bloccante. Il motore JavaScript crea una coda di eventi (che possono essere operazioni di I/O, richieste di rete, chiamate di WebWorker, funzioni inserite in timer ecc.) che, al verificarsi di un evento, possono modificare l'ordine di esecuzione sequenziale del codice. Si prenda come esempio una funzione che scrive "Hello World" ogni 3 secondi: 
\begin{lstlisting}
function myFunction() {
	setInterval(function() { 
		alert("Hello World"); 
	}, 3000);
}
\end{lstlisting}
JavaScript interagisce col browser attraverso il DOM (\textbf{D}ocument \textbf{O}bject \textbf{M}odel) della pagina HTML. Il DOM è stato standardizzato dalla W3C e viene creato dal browser dopo che una pagina è stata caricata. Esso segue un modello gerarchico di oggetti (Figura \ref{fig:dom}) che possono essere manipolati dagli script dando la possibilità di aggiornare dinamicamente il contenuto, la struttura e lo stile dei documenti. Grazie al DOM è possibile accedere agli elementi (e loro proprietà, metodi ed eventi) delle pagine HTML.

jQuery (sezione javascript della mia relazione di pwm), libro headfirstjavascript pagina 664 \\
AJAX altro esempio di evento (sezione ajax della mia relazione di pwm)

\begin{figure}
	\center{\includegraphics[width=0.55\linewidth]{./img/dom.png}}
	\caption{Esempio di gerarchia del DOM in un documento HTML. Immagine sotto licenza CC BY-SA 3.0. Autore: Birger Eriksson. Link: \url{https://commons.wikimedia.org/wiki/File:DOM-model.svg}}
	\label{fig:dom}
\end{figure}


%
% 
%			CAPITOLO 4: Analisi del progetto
\chapter{Analisi del progetto}
\label{cap4}
Prestazioni: ?
\\
Problema sicurezza: clonare il telecomando, ...
\\
Possibili miglioramenti: sistema di login sul sito per l'amministratore,
sensore per il rilevamento delle persone durante la chiusura delle porte,
...
\\


%			CAPITOLO 5: Conclusioni
\chapter{Conclusioni}
\label{cap5}
%

\appendix
\chapter{Una prima Appendice (?)}
...


%			BIBLIOGRAFIA
%
\begin{thebibliography}{00}
%
%	

\bibitem{controllo_accessi}
J. Allen, Opening new doors with IP access control, 16 Marzo, 2018. \url{https://www.axis.com/blog/secure-insights/opening-new-doors-with-ip-access-control/}
%

\bibitem{crescita_controllo_accessi}
R. Alalouff, Access control leads growth in physical security market but video surveillance still dominates, 25 Gennaio, 2018.
\url{https://www.ifsecglobal.com/access-control/access-control-leads-growth-physical-security-market-video-surveillance-still-dominates/}
%
\bibitem{smart_objects}
A. Tumino, Internet of Things: gli oggetti intelligenti prima di ogni "cosa", 24 Gennaio, 2018.
\url{https://blog.osservatori.net/it_it/internet-of-things-oggetti-intelligenti-prima-di-ogni-cosa}
%
\bibitem{IoT}
M. Rouse, Internet of Things (IoT), ultimo aggiornamento Marzo 2019.
\url{https://internetofthingsagenda.techtarget.com/definition/Internet-of-Things-IoT}
% 
\bibitem{arduino_storia}
Arduino, Un po' di storia.
\url{https://playground.arduino.cc/Italiano/StoriaDiArduino/}
%

\bibitem{sistemi_embedded_atrent}
A. Carraturo, A. Trentini, Sistemi Embedded: Teoria e Pratica, prima edizione: Settembre 2017.
\url{http://www.ledizioni.it/prodotto/a-carraturo-a-trentini-sistemi-embedded-teoria-pratica/}
%
\bibitem{i2c_vs_spi}
S. Hymel, SPI vs I2C Protocol Differences and Things to Consider, ultimo aggiornamento Dicembre 2018.
\url{https://articles.saleae.com/logic-analyzers/spi-vs-i2c-protocol-differences-and-things-to-consider}
%
\bibitem{javascript}
Mozilla, JavaScript, ultimo aggiornamento Maggio 2019.
\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript}
%
\bibitem{eloquent_javascript}
M. Haverbeke, ELOQUENT JAVASCRIPT: A modern Introduction to Programming, terza edizione.
\url{https://eloquentjavascript.net/}
\end{thebibliography}
%
\end{document}


 
